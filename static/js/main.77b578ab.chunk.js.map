{"version":3,"sources":["logic/direction.ts","app/App.styled.tsx","components/RangeInput.tsx","util/color.ts","util/array.ts","util/number.ts","logic/segment.ts","logic/random.ts","logic/path.ts","logic/individual.ts","logic/problem.ts","components/BoardCanvas.tsx","app/App.tsx","index.tsx"],"names":["Direction","CanvasContainer","styled","div","height","width","RangeInput","value","onChange","children","props","className","type","e","target","parseInt","COLORS","HUE","INTENSITY","LIGHTNESS","getColor","i","length","Math","floor","getHSL","compareTuples","a","b","times","n","fun","Array","map","_","splitAt","list","at","slice","DIRECTIONS","Up","Right","Down","Left","rotate","direction","degrees","offset","directionOffset","findIndex","item","Error","directionValue","isHorizontal","randomBetween","min","max","random","randomBool","segmentToCoordinates","start","segment","startX","startY","distance","modifierX","modifierY","roulette","sum","reduce","acc","number","places","weighed","progress","weight","topBound","round","newProgress","rouletteDraw","take","find","WEIGHT","generatePath","index","end","endX","endY","generated","generateSegments","current","currentX","currentY","leftValue","rightValue","upValue","downValue","directions","maxDistance","isVertical","coordinate","abs","newCurrent","segments","mergeSegments","last","lastDistance","lastDirection","newDistance","newDirection","mutatePath","path","problem","mutationChance","segmentId","mutation","mutationDirection","mutationDistance","splitPoint","mutateSegment","newSegments","merged","clonePath","pair","cloneSegment","individualToCoordinates","individual","paths","initial","coordinates","segmentCoordinates","pathToCoordinates","errorValues","outOfBounds","Object","entries","filter","x","y","grouped","duplication","values","calculateFitness","fitness","outOfBoundsWeights","duplicationWeights","errors","exp","indexes","segmentsCount","getFitness","generateProblem","connectors","populationSize","population","connector","generateIndividual","calculateProblemFitness","getPopulationBest","best","adapt","previousBest","currentBest","Set","forEach","add","newOutOfBoundsWeights","has","toString","group","newDuplicationWeights","populate","newPopulation","parents","mutatedPaths","mutateIndividual","pathsA","pathsB","crossOver","runProblem","run","window","_setGeneration","_isRunning","_setIndividual","populated","calculated","adapted","bestIndividual","Promise","resolve","setTimeout","translate","pos","BoardCanvas","ref","useRef","useEffect","canvas","ctx","getContext","fillStyle","clearRect","xPos","yPos","beginPath","arc","PI","fill","closePath","hue","lightness","lineWidth","lineCap","lineJoin","strokeStyle","moveTo","lineTo","stroke","App","useState","setWidth","setHeight","setPopulation","setMutation","selected","setSelected","setConnectors","setProblem","setIndividual","generation","setGeneration","newConnectors","handleConnectorClick","position","hasConnector","handleDeleteConnection","before","after","style","maxWidth","gridTemplateColumns","gridTemplateRows","isSelected","color","intensity","onClick","disabled","gridArea","step","undefined","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.77b578ab.chunk.js","sourcesContent":["import { Pair } from \"util/array\";\n\nexport enum Direction {\n  Up = \"Up\",\n  Down = \"Down\",\n  Left = \"Left\",\n  Right = \"Right\",\n}\nconst DIRECTIONS = [Direction.Up, Direction.Right, Direction.Down, Direction.Left];\n\nexport const rotate = (direction: Direction, degrees: number) => {\n  const offset = (directionOffset(direction) + Math.floor(degrees / 90)) % DIRECTIONS.length;\n  return DIRECTIONS[offset];\n};\n\nexport const directionOffset = (direction: Direction): number => {\n  const offset = DIRECTIONS.findIndex((item) => item === direction);\n  if (offset < 0) throw new Error(\"Incorrect direction passed\");\n  return offset;\n};\n\nexport const directionValue = (direction: Direction): Pair<number> => {\n  if (direction === Direction.Up) return [0, -1];\n  if (direction === Direction.Down) return [0, 1];\n  if (direction === Direction.Left) return [-1, 0];\n  if (direction === Direction.Right) return [1, 0];\n  throw new Error(\"Incorrect direction passed\");\n};\n\nexport const isHorizontal = (direction: Direction) =>\n  direction === Direction.Left || direction === Direction.Right;\n\nexport const isVertical = (direction: Direction) =>\n  direction === Direction.Up || direction === Direction.Down;\n","import styled from \"@emotion/styled\";\n\ntype Props = {\n  width: number;\n  height: number;\n};\n\nexport const CanvasContainer = styled.div<Props>`\n  width: 100%;\n\n  &::before {\n    content: \"\";\n    display: block;\n    padding-bottom: ${({ height, width }) => (height * 100) / width}%;\n  }\n\n  > div > button {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n\n    div {\n      width: 75%;\n      border-radius: 50%;\n      max-width: 0.75rem;\n      &::after {\n        content: \"\";\n        padding-bottom: 100%;\n        display: block;\n      }\n    }\n  }\n`;\n","import { ChangeEvent, InputHTMLAttributes, ReactNode } from \"react\";\n\ntype Props = Omit<InputHTMLAttributes<HTMLInputElement>, \"onChange\"> & {\n  onChange: (arg: number) => void;\n  value: number;\n  children?: (value: number) => ReactNode;\n};\n\nexport const RangeInput = ({ value, onChange, children, ...props }: Props) => {\n  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {\n    if (e?.target?.value == null) return;\n    const value = parseInt(e.target.value);\n    onChange(value);\n  };\n\n  return (\n    <div className=\"flex w-full\">\n      <input type=\"range\" className=\"flex-1\" onChange={handleChange} value={value} {...props} />\n      <div className=\"w-12 font-bold ml-2 text-right\">\n        {!children && value}\n        {!!children && children(value)}\n      </div>\n    </div>\n  );\n};\n","export const COLORS = [\"red\", \"yellow\", \"green\", \"blue\", \"purple\", \"pink\"];\nexport const HUE = [0, 38, 160, 217, 258, 330];\n\nexport const INTENSITY = [500, 300, 900];\nexport const LIGHTNESS = [60, 80, 40];\n\nexport const getColor = (i: number): [string, number] => [\n  COLORS[i % COLORS.length],\n  INTENSITY[Math.floor(i / COLORS.length) % INTENSITY.length],\n];\n\nexport const getHSL = (i: number): [number, number] => [\n  HUE[i % HUE.length],\n  LIGHTNESS[Math.floor(i / HUE.length) % LIGHTNESS.length],\n];\n","export type Pair<T> = [T, T];\n\nexport const compareTuples = <T>(a: Pair<T>, b: Pair<T>): boolean => a[0] === b[0] && a[1] === b[1];\n\nexport const clonePair = <T>(pair: Pair<T>): Pair<T> => [pair[0], pair[1]];\n\nexport const times = <T>(n: number, fun: (index: number) => T) =>\n  [...new Array(n)].map((_, i) => fun(i));\n\nexport const splitAt = <T>(list: T[], at: number): [T[], T[]] => [\n  list.slice(0, at),\n  list.slice(at),\n];\n","export const roundTo = (number: number, places: number) =>\n  Math.round(number * 10 ** places) / 10 ** places;\n\nexport const randomBetween = (min: number, max: number) =>\n  Math.floor(Math.random() * (max - min)) + min;\n\nexport const randomBool = () => Math.random() < 0.5;\n","import { Pair, times } from \"util/array\";\nimport { Direction, directionValue, isHorizontal, rotate } from \"logic/direction\";\nimport { randomBetween, randomBool } from \"util/number\";\n\nexport type Segment = [number, Direction];\n\nexport const segmentToCoordinates = (start: Pair<number>, segment: Segment): Pair<number>[] => {\n  const [startX, startY] = start;\n  const [distance, direction] = segment;\n  const [modifierX, modifierY] = directionValue(direction);\n  return times(distance, (n) => [startX + (n + 1) * modifierX, startY + (n + 1) * modifierY]);\n};\n\nexport const mutateSegment = (segment: Segment, width: number, height: number): Segment[] => {\n  const [distance, direction] = segment;\n  const mutationDirection = rotate(direction, randomBool() ? 90 : 270);\n  const mutationDistance = randomBetween(1, isHorizontal(direction) ? height : width);\n\n  if (distance == 1 || randomBool())\n    return [\n      [mutationDistance, mutationDirection],\n      [distance, direction],\n      [mutationDistance, rotate(mutationDirection, 180)],\n    ];\n\n  const splitPoint = randomBetween(1, distance);\n  if (randomBool())\n    return [\n      [mutationDistance, mutationDirection],\n      [splitPoint, direction],\n      [mutationDistance, rotate(mutationDirection, 180)],\n      [distance - splitPoint, direction],\n    ];\n\n  return [\n    [splitPoint, direction],\n    [mutationDistance, mutationDirection],\n    [distance - splitPoint, direction],\n    [mutationDistance, rotate(mutationDirection, 180)],\n  ];\n};\n\nexport const cloneSegment = (segment: Segment): Segment => [segment[0], segment[1]];\n","import { roundTo } from \"util/number\";\nimport { times } from \"util/array\";\n\nexport const roulette = <T>(list: [T, number][]) => {\n  const sum = list.reduce((acc, [, weight]) => acc + weight, 0);\n  const { weighed } = list.reduce(\n    ({ weighed, progress }, [item, weight]) => {\n      const topBound = roundTo(weight / sum, 4);\n      if (topBound === 0) return { weighed, progress };\n      const newProgress = topBound + progress;\n      return {\n        weighed: [...weighed, [item, newProgress]] as typeof list,\n        progress: newProgress,\n      };\n    },\n    { weighed: [] as typeof list, progress: 0 },\n  );\n\n  return weighed;\n};\n\nexport const rouletteDraw = <T>(roulette: [T, number][], take = 2) => {\n  return times(take, () => {\n    const random = Math.random();\n    const [item] = roulette.find(([, weight]) => weight > random) || roulette[0];\n    return item;\n  });\n};\n","import { clonePair, compareTuples, Pair, splitAt } from \"util/array\";\nimport { cloneSegment, mutateSegment, Segment, segmentToCoordinates } from \"logic/segment\";\nimport { Connector, Problem } from \"logic/problem\";\nimport { roulette, rouletteDraw } from \"logic/random\";\nimport { Direction, isHorizontal, isVertical, rotate } from \"logic/direction\";\nimport { randomBetween } from \"util/number\";\n\nexport type Path = {\n  start: Pair<number>;\n  index: number;\n  segments: Segment[];\n};\n\nexport const pathToCoordinates = ({ segments, start, index }: Path) => {\n  const initial = {\n    coordinates: [start],\n    start,\n  };\n  const { coordinates } = segments.reduce(({ coordinates, start }, segment) => {\n    const segmentCoordinates = segmentToCoordinates(start, segment);\n    const [, [last]] = splitAt(segmentCoordinates, -1);\n    return {\n      coordinates: [...coordinates, ...segmentCoordinates],\n      start: last,\n    };\n  }, initial);\n\n  return coordinates.map(([x, y]) => [x, y, index]) as [number, number, number][];\n};\n\nconst WEIGHT = 0.5;\n\nexport const generatePath = (\n  [start, end]: Connector,\n  width: number,\n  height: number,\n  index: number,\n): Path => {\n  const [endX, endY] = end;\n\n  const generateSegments = (current: Pair<number>): Segment[] => {\n    if (compareTuples(current, end)) return [];\n    const [currentX, currentY] = current;\n\n    let leftValue = currentX === 0 ? 0 : 1;\n    let rightValue = currentX === width - 1 ? 0 : 1;\n    let upValue = currentY === 0 ? 0 : 1;\n    let downValue = currentY === height - 1 ? 0 : 1;\n\n    if (currentX > endX) leftValue += (currentX - endX) * WEIGHT;\n    if (currentX < endX) rightValue += (endX - currentX) * WEIGHT;\n    if (currentY > endY) upValue += (currentY - endY) * WEIGHT;\n    if (currentY < endY) downValue += (endY - currentY) * WEIGHT;\n\n    const directions: [Direction, number][] = [\n      [Direction.Left, leftValue],\n      [Direction.Right, rightValue],\n      [Direction.Up, upValue],\n      [Direction.Down, downValue],\n    ];\n\n    const [direction] = rouletteDraw(roulette(directions), 1);\n\n    const maxDistance =\n      direction === Direction.Up\n        ? currentY\n        : direction === Direction.Down\n        ? height - currentY\n        : direction === Direction.Left\n        ? currentX\n        : width - currentX;\n\n    let distance = randomBetween(1, maxDistance);\n    if (\n      (currentX === endX && isVertical(direction)) ||\n      (currentY === endY && isHorizontal(direction))\n    ) {\n      const coordinates = segmentToCoordinates(current, [distance, direction]);\n      const isThroughEnd = coordinates.find((coordinate) => compareTuples(coordinate, end));\n      if (isThroughEnd) {\n        distance = Math.abs(currentX - endX + currentY - endY);\n      }\n    }\n\n    const newCurrent: Pair<number> =\n      direction === Direction.Up\n        ? [currentX, currentY - distance]\n        : direction === Direction.Down\n        ? [currentX, currentY + distance]\n        : direction === Direction.Left\n        ? [currentX - distance, currentY]\n        : [currentX + distance, currentY];\n\n    return [[distance, direction], ...generateSegments(newCurrent)];\n  };\n\n  const generated = generateSegments(start);\n  const segments = mergeSegments(generated);\n  return { start, index, segments };\n};\n\nexport const mergeSegments = (segments: Segment[]): Segment[] => {\n  if (segments.length < 2) return segments;\n  return segments.reduce((segments, segment) => {\n    if (segments.length === 0) return [segment];\n    const [distance, direction] = segment;\n    const [list, [last]] = splitAt(segments, -1);\n    const [lastDistance, lastDirection] = last;\n\n    if (lastDirection === direction) {\n      return [...list, [lastDistance + distance, direction]];\n    }\n    if (lastDirection === rotate(direction, 180)) {\n      const newDistance = lastDistance - distance;\n      if (newDistance === 0) {\n        return list;\n      }\n\n      const newDirection = newDistance < 0 ? direction : rotate(direction, 180);\n      return [...list, [Math.abs(newDistance), newDirection]];\n    }\n\n    return [...segments, [distance, direction]];\n  }, [] as Segment[]);\n};\n\nexport const mutatePath = (path: Path, problem: Problem) => {\n  if (randomBetween(0, 100) > problem.mutationChance) return path;\n\n  const { segments } = path;\n  const { width, height } = problem;\n  const segmentId = randomBetween(0, path.segments.length);\n  const segment = segments[segmentId];\n\n  const mutation = mutateSegment(segment, width, height);\n  const newSegments = [\n    ...segments.slice(0, segmentId),\n    ...mutation,\n    ...segments.slice(segmentId + 1),\n  ] as Segment[];\n\n  const merged = mergeSegments(newSegments);\n  return { ...path, segments: merged };\n};\n\nexport const clonePath = ({ segments, start, index }: Path): Path => ({\n  index,\n  start: clonePair(start),\n  segments: segments.map((segment) => cloneSegment(segment)),\n});\n","import { clonePath, generatePath, mutatePath, Path, pathToCoordinates } from \"logic/path\";\nimport { Connector, Problem } from \"logic/problem\";\nimport { randomBetween } from \"util/number\";\n\nexport type Individual = {\n  paths: Path[];\n  fitness?: number;\n};\n\nexport const generateIndividual = (\n  width: number,\n  height: number,\n  connectors: Connector[],\n): Individual => {\n  const paths = connectors.map((connector, index) => generatePath(connector, width, height, index));\n  return { paths };\n};\n\nexport const individualToCoordinates = (individual: Individual) => {\n  const { paths } = individual;\n  return paths.reduce(\n    (list, path) => [...list, ...pathToCoordinates(path)],\n    [] as ReturnType<typeof pathToCoordinates>,\n  );\n};\n\nexport const errorValues = (individual: Individual, problem: Problem) => {\n  const { width, height } = problem;\n  const coordinates = individualToCoordinates(individual);\n\n  const outOfBounds = Object.entries(\n    coordinates\n      .filter(([x, y]) => x < 0 || y < 0 || x >= width || y >= height)\n      .reduce(\n        (grouped, [, , index]) => ({\n          ...grouped,\n          [index]: (grouped?.[index] ?? 0) + 1,\n        }),\n        {} as { [key: number]: number },\n      ),\n  );\n\n  const duplication = Object.values(\n    coordinates.reduce(\n      (grouped, [x, y, index]) => ({\n        ...grouped,\n        [`${x}-${y}`]: [...(grouped?.[`${x}-${y}`] ?? []), index],\n      }),\n      {} as { [key: string]: number[] },\n    ),\n  ).filter((values) => values.length > 1);\n\n  const length = coordinates.length;\n\n  return { outOfBounds, duplication, length };\n};\n\nexport const getFitness = (individual: Individual, problem: Problem): number => {\n  const { paths } = individual;\n  const { outOfBoundsWeights, duplicationWeights } = problem;\n  const errors = errorValues(individual, problem);\n\n  const outOfBounds = errors.outOfBounds.reduce<number>(\n    (value, [index, exp]) => value + outOfBoundsWeights[parseInt(index)] ** exp,\n    0,\n  );\n\n  const duplication = errors.duplication.reduce(\n    (value, indexes) =>\n      value + indexes.reduce((value, index) => value * duplicationWeights[index], 1),\n    0,\n  );\n  const segmentsCount = paths.reduce((value, { segments }) => value + segments.length, 0);\n\n  return 1 / (errors.length + segmentsCount + outOfBounds + duplication);\n};\n\nexport const calculateFitness = (individual: Individual, problem: Problem): Individual => {\n  const fitness = getFitness(individual, problem);\n  return { ...individual, fitness };\n};\n\nexport const crossOver = (\n  { paths: pathsA }: Individual,\n  { paths: pathsB }: Individual,\n): Individual => {\n  const splitPoint = randomBetween(0, pathsA.length + 1);\n  const paths = [\n    ...pathsA.slice(0, splitPoint).map((path) => clonePath(path)),\n    ...pathsB.slice(splitPoint).map((path) => clonePath(path)),\n  ];\n  return { paths };\n};\n\nexport const mutateIndividual = (individual: Individual, problem: Problem): Individual => {\n  const { paths } = individual;\n  const mutatedPaths = paths.map((path) => mutatePath(path, problem));\n  return { ...individual, paths: mutatedPaths };\n};\n","import { Pair, times } from \"util/array\";\nimport {\n  calculateFitness,\n  crossOver,\n  errorValues,\n  generateIndividual,\n  Individual,\n  mutateIndividual,\n} from \"logic/individual\";\nimport { roulette, rouletteDraw } from \"logic/random\";\n\nexport type Connector = Pair<Pair<number>>;\n\nexport type Problem = {\n  width: number;\n  height: number;\n  connectors: Connector[];\n  population: Individual[];\n  duplicationWeights: number[];\n  outOfBoundsWeights: number[];\n  mutationChance: number;\n};\n\nexport const generateProblem = (\n  width: number,\n  height: number,\n  connectors: Connector[],\n  populationSize: number,\n  mutationChance: number,\n): Problem => {\n  const population = times(populationSize, () => generateIndividual(width, height, connectors));\n  return {\n    width,\n    height,\n    connectors,\n    population,\n    duplicationWeights: times(connectors.length, () => width * height),\n    outOfBoundsWeights: times(connectors.length, () => width * height),\n    mutationChance,\n  };\n};\n\nexport const calculateProblemFitness = (problem: Problem): Problem => {\n  const population = problem.population.map((individual) => calculateFitness(individual, problem));\n  return { ...problem, population };\n};\n\nexport const getPopulationBest = (problem: Problem) => {\n  const { population } = problem;\n  return population.reduce<Individual>((best, individual) => {\n    if (individual?.fitness == null) throw new Error(\"The fitness has not been calculated!\");\n    if (best?.fitness == null) throw new Error(\"The fitness has not been calculated!\");\n\n    return individual.fitness > best.fitness ? individual : best;\n  }, population[0]);\n};\n\nexport const adapt = (previousBest: Individual, problem: Problem): Problem => {\n  const { duplicationWeights, outOfBoundsWeights } = problem;\n  const currentBest = getPopulationBest(problem);\n  if (previousBest?.fitness == null) throw new Error(\"The fitness has not been calculated!\");\n  if (currentBest?.fitness == null) throw new Error(\"The fitness has not been calculated!\");\n\n  if (previousBest.fitness <= currentBest.fitness) return problem;\n\n  const errors = errorValues(currentBest, problem);\n\n  const outOfBounds = new Set<string>();\n  errors.outOfBounds.forEach(([index]) => outOfBounds.add(index));\n  const newOutOfBoundsWeights = outOfBoundsWeights.map((weight, index) =>\n    outOfBounds.has(index.toString()) ? weight + 1 : weight,\n  );\n\n  const duplication = new Set<number>();\n  errors.duplication.forEach((group) => group.forEach((item) => duplication.add(item)));\n  const newDuplicationWeights = duplicationWeights.map((weight, index) =>\n    duplication.has(index) ? weight + 1 : weight,\n  );\n\n  return {\n    ...problem,\n    outOfBoundsWeights: newOutOfBoundsWeights,\n    duplicationWeights: newDuplicationWeights,\n  };\n};\n\nexport const populate = (problem: Problem): Problem => {\n  const { population } = problem;\n  const weighed = roulette(\n    population.map((individual) => {\n      if (individual.fitness == null) throw new Error(\"Fitness not calculated\");\n      return [individual, individual.fitness];\n    }),\n  );\n\n  const newPopulation = population.map(() => {\n    const parents = rouletteDraw(weighed);\n    const child = crossOver(parents[0], parents[1]);\n    return mutateIndividual(child, problem);\n  });\n\n  return { ...problem, population: newPopulation };\n};\n\nexport const runProblem = async (problem: Problem) => {\n  let i = 0;\n\n  const run = async (problem: Problem, best: Individual) => {\n    window._setGeneration(i);\n    if (!window._isRunning) return;\n    if (i++ % 5 === 0) {\n      window._setIndividual(best);\n    }\n\n    const populated = populate(problem);\n    const calculated = calculateProblemFitness(populated);\n    const adapted = adapt(best, calculated);\n    const bestIndividual = getPopulationBest(adapted);\n    await new Promise((resolve) => setTimeout(resolve, 1));\n    await run(adapted, bestIndividual);\n  };\n\n  const calculated = calculateProblemFitness(problem);\n  const best = getPopulationBest(calculated);\n  await run(calculated, best);\n};\n","import { useEffect, useRef } from \"react\";\nimport { Individual } from \"logic/individual\";\nimport { Problem } from \"logic/problem\";\nimport { directionValue } from \"logic/direction\";\nimport { getHSL } from \"util/color\";\n\ntype Props = {\n  individual?: Individual;\n  problem: Problem;\n};\n\nconst UNIT = 50;\nconst WIDTH = 6;\nconst translate = (pos: number) => (pos + 1) * UNIT;\n\nexport const BoardCanvas = ({ individual, problem }: Props) => {\n  const ref = useRef<HTMLCanvasElement>(null);\n  const { width, height, connectors } = problem;\n\n  useEffect(() => {\n    const canvas = ref.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n    ctx.fillStyle = \"#dddddd\";\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    for (let x = 0; x < width; x++) {\n      const xPos = translate(x);\n      for (let y = 0; y < height; y++) {\n        const yPos = translate(y);\n        ctx.beginPath();\n        ctx.arc(xPos, yPos, WIDTH, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.closePath();\n      }\n    }\n\n    for (let i = 0; i < connectors.length; i++) {\n      const [[startX, startY], [endX, endY]] = connectors[i];\n      const [hue, lightness] = getHSL(i);\n      ctx.fillStyle = `hsl(${hue}, 90%, ${lightness}%)`;\n      ctx.beginPath();\n      ctx.arc(translate(startX), translate(startY), WIDTH * 1.2, 0, 2 * Math.PI);\n      ctx.arc(translate(endX), translate(endY), WIDTH * 1.2, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.closePath();\n    }\n\n    if (!individual) return;\n    const { paths } = individual;\n\n    ctx.lineWidth = WIDTH;\n    ctx.lineCap = \"round\";\n    ctx.lineJoin = \"round\";\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const { start, segments } = path;\n      let [startX, startY] = start;\n\n      const [hue, lightness] = getHSL(i);\n      ctx.strokeStyle = `hsl(${hue}, 90%, ${lightness}%)`;\n      ctx.beginPath();\n      ctx.moveTo(translate(startX), translate(startY));\n\n      for (const [distance, direction] of segments) {\n        const [modifierX, modifierY] = directionValue(direction);\n        const endX = startX + distance * modifierX;\n        const endY = startY + distance * modifierY;\n        ctx.lineTo(translate(endX), translate(endY));\n        startX = endX;\n        startY = endY;\n      }\n      ctx.stroke();\n      ctx.closePath();\n    }\n  }, [individual, problem]);\n\n  return (\n    <>\n      <canvas\n        ref={ref}\n        className=\"absolute left-0 top-0 bottom-0 right-0 w-full h-full\"\n        width={(width + 1) * UNIT}\n        height={(height + 1) * UNIT}\n      />\n    </>\n  );\n};\n","import { CanvasContainer } from \"app/App.styled\";\nimport { useEffect, useState } from \"react\";\nimport { RangeInput } from \"components/RangeInput\";\nimport { COLORS, getColor, INTENSITY } from \"util/color\";\nimport { FiTrash2 } from \"react-icons/fi\";\nimport { compareTuples, Pair, times } from \"util/array\";\nimport { Connector, generateProblem, Problem, runProblem } from \"logic/problem\";\nimport { Individual } from \"logic/individual\";\nimport { BoardCanvas } from \"components/BoardCanvas\";\n\ndeclare global {\n  interface Window {\n    _isRunning: boolean;\n    _setIndividual: (arg: Individual) => void;\n    _setGeneration: (arg: number) => void;\n  }\n}\n\nexport const App = () => {\n  const [width, setWidth] = useState(8);\n  const [height, setHeight] = useState(8);\n  const [population, setPopulation] = useState(100);\n  const [mutation, setMutation] = useState(10);\n  const [selected, setSelected] = useState<Pair<number> | null>(null);\n  const [connectors, setConnectors] = useState<Connector[]>([]);\n\n  const [problem, setProblem] = useState<Problem>();\n  const [individual, setIndividual] = useState<Individual>();\n  const [generation, setGeneration] = useState(0);\n\n  window._setIndividual = setIndividual;\n  window._setGeneration = setGeneration;\n\n  useEffect(() => {\n    window._isRunning = !!problem;\n    if (!problem) return;\n    runProblem(problem);\n  }, [problem]);\n\n  useEffect(() => {\n    const newConnectors = connectors.filter(\n      ([start, end]) => start[0] < width && start[1] < height && end[0] < width && end[1] < height,\n    );\n    setConnectors(newConnectors);\n  }, [width, height]);\n\n  const handleConnectorClick = (position: Pair<number>, hasConnector: boolean) => () => {\n    if (problem) return;\n    if (hasConnector) return;\n    if (connectors.length === COLORS.length * INTENSITY.length) return;\n\n    if (selected && compareTuples(selected, position)) return setSelected(null);\n    if (!selected) return setSelected(position);\n    setConnectors([...connectors, [selected, position]]);\n    setSelected(null);\n  };\n\n  const handleDeleteConnection = (i: number) => () => {\n    const before = connectors.slice(0, i);\n    const after = connectors.slice(i + 1);\n    setConnectors([...before, ...after]);\n  };\n\n  const handleStart = () => {\n    const problem = generateProblem(width, height, connectors, population, mutation);\n    setProblem(problem);\n    setIndividual(undefined);\n  };\n\n  return (\n    <div className=\"h-screen overflow-y-auto overflow-x-hidden scrollbar-thin scrollbar-thumb-rounded scrollbar-thumb-gray-400\">\n      <main className=\"bg-gray-200 md:bg-gray-100 min-h-screen w-full flex flex-col md:flex-row items-stretch\">\n        <section className=\"flex-grow flex items-center justify-center flex-col h-screenpeek md:h-auto sticky top-0\">\n          <CanvasContainer\n            className=\"bg-white relative rounded-xl shadow-2xl\"\n            style={{\n              maxWidth: `min(calc(${width} / ${height} * 80%), 80%, calc(${width} / ${height} * 80vh))`,\n            }}\n            {...{ width, height }}\n          >\n            {problem && <BoardCanvas {...{ problem, individual }} />}\n            {!problem && (\n              <div\n                className=\"absolute left-0 top-0 bottom-0 right-0 w-full h-full grid place-items-center\"\n                style={{\n                  gridTemplateColumns: `1fr repeat(${width}, 2fr) 1fr`,\n                  gridTemplateRows: `1fr repeat(${height}, 2fr) 1fr`,\n                }}\n              >\n                {times(height, (y) =>\n                  times(width, (x) => {\n                    const coordinates: Pair<number> = [x, y];\n                    const connector = connectors?.findIndex(\n                      ([start, end]) =>\n                        compareTuples(start, coordinates) || compareTuples(end, coordinates),\n                    );\n                    const hasConnector = connector != null && connector >= 0;\n                    const isSelected = selected && compareTuples(selected, coordinates);\n                    const [color, intensity] = hasConnector\n                      ? getColor(connector)\n                      : isSelected\n                      ? [\"gray\", 600]\n                      : [\"gray\", 300];\n\n                    return (\n                      <button\n                        key={`${x}-${y}`}\n                        className={`${!hasConnector && !problem ? \"group\" : \"cursor-default\"}`}\n                        onClick={handleConnectorClick(coordinates, hasConnector)}\n                        disabled={problem || hasConnector}\n                        style={{\n                          gridArea: `${y + 2} / ${x + 2} / span 1 / span 1`,\n                        }}\n                      >\n                        <div\n                          className={`bg-${color}-${intensity} ${\n                            isSelected ? \"ring-4 ring-gray-300\" : \"\"\n                          } ${\n                            hasConnector ? `ring-4 ring-${color}-100` : \"group-hover:bg-gray-600\"\n                          }`}\n                        />\n                      </button>\n                    );\n                  }),\n                )}\n              </div>\n            )}\n          </CanvasContainer>\n        </section>\n        <aside className=\"md:max-w-xs md:w-1/2 p-8 pt-12 md:pt-8 md:border-l-2 bg-gray-100 z-10 rounded-t-3xl md:rounded-none shadow-blur md:shadow-none md:max-h-screen overflow-y-auto scrollbar-thin scrollbar-thumb-rounded scrollbar-thumb-gray-400\">\n          <div className=\"flex flex-col max-w-sm mx-auto\">\n            {!problem && (\n              <>\n                <section>\n                  <label className=\"block\">\n                    <h1 className=\"font-bold text-gray-700\">Width</h1>\n                    <RangeInput value={width} onChange={setWidth} min={5} max={20} />\n                  </label>\n\n                  <label className=\"mt-4 block\">\n                    <h1 className=\"font-bold text-gray-700\">Height</h1>\n                    <RangeInput value={height} onChange={setHeight} min={5} max={20} />\n                  </label>\n\n                  <div className=\"mt-4\">\n                    <h1 className=\"font-bold text-gray-700\">Connections</h1>\n                    <div className=\"border-2 bg-gray-50 rounded-lg px-4 h-40 overflow-y-auto mt-1 scrollbar-thin scrollbar-thumb-rounded scrollbar-thumb-gray-400\">\n                      {!connectors?.length && (\n                        <div className=\"text-center text-gray-400 text-sm h-full w-full flex justify-center items-center\">\n                          No connections found\n                        </div>\n                      )}\n                      {connectors.map(([start, end], i) => {\n                        const [color, intensity] = getColor(i);\n                        return (\n                          <div\n                            key={`${start[0]}-${start[1]}`}\n                            className=\"flex items-center py-2 group\"\n                          >\n                            <div\n                              className={`w-2 h-2 rounded-full mr-2 ring-2 bg-${color}-${intensity} ring-${color}-100`}\n                            />\n                            <span className=\"text-sm text-gray-600\">\n                              ({start[0]}, {start[1]}) - ({end[0]}, {end[1]})\n                            </span>\n                            <button\n                              className=\"p-1 ml-auto hover:opacity-100 opacity-50 transition-opacity focus:outline-none\"\n                              onClick={handleDeleteConnection(i)}\n                            >\n                              <FiTrash2 className=\"group-hover:opacity-100 opacity-30 transition-opacity\" />\n                            </button>\n                          </div>\n                        );\n                      })}\n                    </div>\n                  </div>\n                </section>\n                <section className=\"mt-10\">\n                  <label className=\"block\">\n                    <h1 className=\"font-bold text-gray-700\">Population</h1>\n                    <RangeInput\n                      value={population}\n                      onChange={setPopulation}\n                      min={50}\n                      max={1000}\n                      step={50}\n                    />\n                  </label>\n\n                  <label className=\"mt-4 block\">\n                    <h1 className=\"font-bold text-gray-700\">Mutation chance</h1>\n                    <RangeInput value={mutation} onChange={setMutation} min={1} max={80} step={1}>\n                      {(value) => <>{value}%</>}\n                    </RangeInput>\n                  </label>\n                </section>\n                {connectors?.length < 2 && (\n                  <button\n                    className=\"rounded-lg bg-gray-400 text-gray-100 font-bold p-3 mt-10 shadow-lg\"\n                    disabled\n                  >\n                    Start\n                  </button>\n                )}\n                {connectors?.length >= 2 && (\n                  <button\n                    className=\"rounded-lg bg-blue-600 hover:bg-blue-700 transition-colors focus:outline-none text-gray-100 font-bold p-3 mt-10 shadow-lg\"\n                    onClick={handleStart}\n                  >\n                    Start\n                  </button>\n                )}\n              </>\n            )}\n            {problem && (\n              <div className=\"d-flex justify-center flex-col my-auto\">\n                <h1 className=\"font-bold text-gray-700\">Generation</h1>\n                <div className=\"mx-auto mb-4\">{generation}</div>\n                <button\n                  className=\"rounded-lg bg-gray-500 hover:bg-gray-600 transition-colors focus:outline-none text-gray-100 font-bold p-3 shadow-lg w-full\"\n                  onClick={() => setProblem(undefined)}\n                >\n                  Stop\n                </button>\n              </div>\n            )}\n          </div>\n        </aside>\n      </main>\n    </div>\n  );\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport { App } from \"app/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\"),\n);\n"],"sourceRoot":""}